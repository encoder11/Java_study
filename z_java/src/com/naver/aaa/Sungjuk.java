
//*********************************
//아래에 나오는 클래스의 소속 패키지경로를 설정하기
//모든 자바 클래스 최상단에는 소속 패키지경로가 먼저 나온다.
//*********************************
package com.naver.aaa;

//*********************************
//Sungjuk 이란 이름의 클래스 선언하기
//클래스?=> 속성변수와 메소드와 생성잘 구성된 단위 프로그램
//클래스 속성변수와 메소드를 호출하려면 클래스 메모리공간에 올려 객체화
//*********************************
public class Sungjuk {
	//---------------------
	//속성변수 선언
	//---------------------
	//학생번호 저장 속성변수 선언
	private int s_no;
	//학생이름 저장 속성변수 선언
	private String s_name;
	//국어점수 저장 속셩변수 선언
	private int kor;
	//영어점수 저장 속성변수 선언
	private int eng;
	//누적된 학생 수를 저장할 속성변수 선언
	public static int cnt;
	//---------------------
	//생성자 선언
	//생성자는 객체 생성시 단 1회만 자동으로 호출
	//생성자의 주된 역활은 객체 생성시 호출되면서 외부에서 들어오는 데이터를
	//속성변수에 저장하는 역활이다.
	//---------------------
	public Sungjuk(int s_no,String s_name,int kor,int eng){
		//매개변수  s_no 저장된 데이터를 속성변수 s_no 에 저장하기
		 this.s_no=s_no;
		//매개변수  s_name 저장된 데이터를 속성변수 s_name 에 저장하기
		 this.s_name=s_name;
		//매개변수  kor 저장된 데이터를 속성변수 kor 에 저장하기
		 this.kor = kor;
		//매개변수  eng 저장된 데이터를 속성변수 eng 에 저장하기
		 this.eng = eng;
		//속성변수 cnt에 1증가
		 cnt++;
	}
	
	//---------------------
	//메소드 선언
	//---------------------
	//학생번호를 리턴하는 메소드 선언
	public int getS_no() {
		//학생번호가 저장된 속성변수안의  데이터를 리턴
		return s_no;
	}
	//학생번호를 리턴하는 메소드 선언
	public String getS_name() {
		//학생이름이 저장된 속성변수안의  데이터를 리턴
		return s_name;
	}
	
	
	
	
	//총점을 리턴하는 메소드 선언 //에러발생시 에러발생하는 줄번호 적기 시험문제
	public int getTot() {
		//지역변수 tot 선언하고 속성변수 kor 과 속성변수 eng 에 저장된
		//데이터를 더해서 tot 에 저장하기
	int tot =kor+eng;
		return tot;
	}
	//평균을 리턴하는 메소드 선언
	public double getAvg() {
		//지역변수 avg 선언하고 동료 메소드를 호출하여 얻는 총점을 avg 에 저장하기
		double avg = getTot()/2.0;
		//avg 변수안의 데이터를 리턴하기
		return avg;
	}
}


/*---------------------------------------------------
<문> public class Sungjuk{~} 에서 public 를 생략하면?
---------------------------------------------------
com.naver.bbb.SungjukExe 클래스에서 import 구문에서 에러 발생
클래스 앞에 public 이 없으면 다른 패키지의 클래스에서 수입이 불가능하다.
<주의>com.naver.aaa.sungjukExe 클래스에서는 에러가 발생하지 않는다.
		동일한 패키지의 안의 타 클래스에서는 public 이 있던 없던 수입이 가능하다.
		심지어 import 구문이 없어도 자동 수입된다.

---------------------------------------------------
<문>생성자 public Sungjuk(int s_no,int kor,int eng){~} 에서 public 를 생략하면?
---------------------------------------------------
com.naver.bbb.SungjukExe 클래스의 Sungjuk sungjuk=new Sungjuk(1,90,80); 에서 에러발생.
 생성자 앞에 defult 가 붙으면(=생략되면) 타 패키지 클래스 안에서 new 에 의해 객체화 될때
 생성자를 안 보이게 함으로써 객체화를 불가능하게 한다.



---------------------------------------------------
<문>생성자 public Sungjuk(int s_no,int kor,int eng){~} 생략하면?
---------------------------------------------------
com.naver.aaa.SungjukExe 클래스의
		Sungjuk sungjuk=new Sungjuk(1,90,80); 에서 에러발생.
com.naver.bbb.SungjukExe 클래스의
		ungjuk sungjuk=new Sungjuk(1,90,80); 에서 에러발생.
 new Sungjuk(1,90,80)의 의미는 수입된 클래스 중에 Sungjuk(~,~,~) 라는 생성자를 가진 
 클래스를 찾아서 객체화 하라는 의미인데 없으므로 객체화 실패로 인해 에러가 발생한다.
<주의>생성자가 0개면 컴파일할 때 자동으로 public 생성자명(){}가 삽입된다.

---------------------------------------------------
<문> public double getAvg() {~} 에서 public 생략하면?
---------------------------------------------------
 com.naver.bbb.SungjukExe 클래스의
 	System.out.printIn("[평균]"+sungjuk.getAvg() ); 에서 에러 발생.
 	메소드에 접근지정자가 defult 면 타 패키지의 클래스 안에서 객체 생성후 호출을 불허한다.
 	메소드에 접근지정자가 defult 면 동일 패키지의 타클래스 안에서 객체생성후 호출을 허가한다.
 	
---------------------------------------------------
<문> 메소드 public double getAvg() {~} 에서 public 을 private 로 수정하면?
---------------------------------------------------
com.naver.aaa.SungjukExe 클래스의
		System.out.println("[평균]"+sungjuk.getAvg() ); 에서 에러 발생
com.naver.bbb.SungjukExe 클래스의
		System.out.println("[평균]"+sungjuk.getAvg() ); 에서 에러 발생
	메소드에 접근지정자가 private 면 동료 메소드/속성변수 에서만 호출이 가능하다.
	타 클래스에서 절대 호출이 불가능하다. 
		
---------------------------------------------------
<문> 메소드 public Sungjuk(int s_no,int kor,int eng){~} 에서
			public 를 private 로 수정하면?
---------------------------------------------------
com.naver.aaa.SungjukExe 클래스의
		System.out.println("[평균]"+sungjuk.getAvg() ); 에서 에러 발생
com.naver.bbb.SungjukExe 클래스의
		System.out.println("[평균]"+sungjuk.getAvg() ); 에서 에러 발생
생성자의 접근지정자가 private 면 타 클래스 에서 new 의한 객체화를 할수 없다.
즉 생성자의 접근지정자가 private 면 그 누구도 생성자를 찾을수 없기 때문이다.	
	
---------------------------------------------------
<문> private int s_no; 를 private final s_no; 로 수정하면?
---------------------------------------------------

---------------------------------------------------
<문> 속성변수 private int s_no; 를 private final int s_no; 로 수정하면?
---------------------------------------------------
에러는 없다
final 이 붙은 속성변수는 자동 초기화가 안된다.
그러므로 속성변수 선언 시 수동 초기화 하던가 아니면 생성자 안에서 수동 초기화 해야한다.
현재 속셩변수 선언 시 수동 초기화 하지 않았지만 생성자 안에서 수동 초기화학 있으므로
에러가 발생하지는 않는다.
만약 생성자 안의 this.s_no =s_no; 를 생략하면 에러가 발생한다.

---------------------------------------------------
<문> public int getTot(){~} 를 public abstract int getTot(){~} 로 수정하면?
---------------------------------------------------
public abstract int getTot(){~}에서 에러발생.
	abstract 가 붙은 메소드는 {}가 없어야하므로 에러 발생
public class Sungjuk{~} 에서 에러 발생.
	abstract 가 붙은 메소드를 클래스 마빡에도 abstract 가 붙어야 하므로 에러 발생.
	
---------------------------------------------------
<문>public int getTot(){~}을 public final int getTot(){~} 로 수정하면?
---------------------------------------------------
에러는 없다.
final 가 붙은 메소드는 상속받은 자식 클래스에서 메소드를 오버라이딩(=재정의)하지 말라는 의미이다.
만약 에러발생한다면 상속받은 자식 클래스에서 메소드를 오버라이딩 할때 에러가 발생할 것이다.
---------------------------------------------------
<문>public int getTot(){~} 를 public static int getTot(){~}로 수정하면?
---------------------------------------------------
public static int getTot(){~}에서 에러 발생.
	static 가 붙은 메소드는 객체 생성없이 Sungjuk.메소드명() 형식으로 호출이 가능하다.
	객체 생성없이 호출이 가능하려면 static 이 붙은 메소드 안에 나오는
	동료 속성변수와 동료 메소드에도 static 이 붙어야 한다.
	
---------------------------------------------------
<문>public double getAvg() {~} 를 public int getAvg(){~}로 수정하면?
---------------------------------------------------
return avg; 에서 에러 발생.
메소드의 리턴형이 int 면 메소드 안의 실행구문에는 반드시 return 정수형 데이터;
나와야한다 현재 return 실수형데이터; 이므로 에러 발생.
결국 메소드의 리턴형과 실제 실행구문에서 리턴하는 데이터 유형은 같아야 한다.

---------------------------------------------------
<문>double avg = getTot()/2.0; 에서 getTot()의 리턴값은 정수다
	왜 정수를 2.0으로 나누면 왜 실수 인가?
---------------------------------------------------
자바는 정수를 정수로 나누면 결과는 무조건 정수이다. 5/2 는 2.5가 아니라 2다.
자바는 실수를 실수로 나누면 결과는 무조건 실수이다. 5.0/2.0 은 2.5 다.
자바는 정수를 실수로 나누면 결과는 무조건 실수이다. 5/2.0 은 2.5 다.
	자바는 서로 다른 유형을 데이터를 연산하면자료형 우선순위를 참고하여 
	한 쪾이 다른 쪽의 데이터 유형으로 바뀐다.
	즉 5/2.0은 5.0/2.0 으로 바뀌어 연산을 한다.
	이렇게 암시적으로 자동으로 자료형이 바뀌는 현상을 [암시적 형변환=	] 이라고한다. 
	연산시 자료형 우선순위는 다음과 같다.
	 byte<short<int<long<float<double
	 
	 
	 
	 double xxx=5/2; //2.0
	 //------------------------
	 double xxx=5.0/2 //2.5
	 double xxx=5/2.0 //2.5
	 double xxx=5.0/2.0 //2.5
	 //------------------------
	 double xxx=(douvle)5/2; //2.5
	 //------------------------
	 
	 Xxx x= new Xxx();
	 Yyy y=(Yyy)x
	 
---------------------------------------------------
<문>public static int cnt; 에서 static 를 생략하면?
---------------------------------------------------
com.naver.aaa.SungjukExe 클래스의
		System.out.println("[조회수]:"+sungjuk.cnt ); 에서 값이 1출력
		System.out.println("[조회수]:"+sungjuk2.cnt ); 에서 값이 1출력
		
속성변수에 static 이 붙을 경우 특징
	<1>객체 생성 없이 클래스명 속성변수명 으로 호출이 가능하다.
	<2>2번 이상 객체화 할 경우 각각의 객체가 속성변수를 공유한다.
	   즉 한 쪽이 업데이트하면 다른 쪽이 인지를 한다.
	   
문제에서 static 을 생략하였으므로 2개의 객체가 공유하지 않아 1만 들어 있다.
*/





























